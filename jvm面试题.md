## 1. JVM内存结构说一下

线程共享：堆，方法区

线程私有：程序计数器，虚拟机栈，本地方法栈

<img src="img/jvm面试题.assets/copy.jpg" alt="img"  />



**虚拟机栈**：每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧(Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致。主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

**本地方法栈**：本地方法栈用于管理本地方法的调用

**程序计数器：**用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令



**栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。**

**堆：** Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。

虚拟机把堆内存逻辑上划分成三块区域（分代的唯一理由就是优化 GC 性能）： 
- 新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代
- 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大 
- 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存

## 2. 垃圾回收算法

### 1.标记-清除
### 2.标记-整理
### 3.复制
### 4.分代收集



## 3. 判断一个对象是否可被回收

### 1. 引用计数算法

给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。

正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

### 2. 可达性分析算法

通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。

Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:

- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

